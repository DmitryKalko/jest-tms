// что бы что-то протестировать, нам нужно сначало это импортировать в файл теста
// это помогает нам следить за модульностью кода(его универсальностью - для переиспользования)

const {sum, nativeNull} = require('./intro');

// it тоже самое что test('name', callback, timeout) timeout - необязательный параметр(по умолчанию 5 секунд, полезно при тестировании асинхронного кода, что бы тест не завершился мгновенно)

test('название теста', () => {
    // и колбэк в котором будем описывать тест
    expect(sum(1, 3)).toBe(4); // toBe - точное попадание в результат
    // expect - это встроеный метод jest
    // toBe - это мэтчер (сопоставление)
    // в одном тесте может быть несколько expect и что бы тест прошел нужно чтобы все выполнились успешно
});

// toEqual - точное попадание в результат, для проверки значения объекта:

test('присваивание объекту', () => {
  const data = {one: 1};
  data['two'] = 2;
  expect(data).toEqual({one: 1, two: 2});
});

test('проверка на что-то', () => {
    expect(sum(2, 3)).toBeGreaterThan(4) // проверка на больше чем
    expect(sum(2, 3)).toBeGreaterThanOrEqual(5) // проверка на больше чем или равно
    expect(sum(2, 3)).toBeLessThan(10) // проверка на меньше чем
    expect(sum(2, 3)).toBeLessThanOrEqual(5) // проверка на меньше чем или равно
})

test('когда проверяем на нецелые числа', () => {
    expect(sum(0.1, 0.2)).toBeCloseTo(0.3); // должен быть близок к
})



describe('позволяет объединять несколько тест-кейсов', () => {  // обертка для нескольких тестов по обной теме
    test('проверка на что-то', () => {
        expect(sum(2, 3)).toBeGreaterThan(4) // проверка на больше чем
        expect(sum(2, 3)).toBeGreaterThanOrEqual(5) // проверка на больше чем или равно
        expect(sum(2, 3)).toBeLessThan(10) // проверка на меньше чем
        expect(sum(2, 3)).toBeLessThanOrEqual(5) // проверка на меньше чем или равно
    })
    
    test('когда проверяем на нецелые числа', () => {
        expect(sum(0.1, 0.2)).toBeCloseTo(0.3); // должен быть близок к
    })
})


test('проверка на ', () => {
    expect(nativeNull()).toBeNull()
    // expect(nativeNull()).toBeNaN()
    expect(nativeNull()).toBeFalsy()
    expect(nativeNull()).toBeDefined() // проверка на то что это определенное значение (т е не underfined)
    // инверсивные матчеры
    expect(nativeNull()).not.toBeTruthy() // проверка на не truthy
    // expect(nativeNull()).not.toBeUnderfined() // проверка на не underfined

})

// Проверка содержит ли массив или итерируемый объект конкретное значение - toContain
// test('the shopping list has milk on it', () => {
//     expect(shoppingList).toContain('milk');
//   });

// ТЕСТИРОВАНИЕ АСИНХРОННОГО КОДА

// КОЛБЭКИ

// По умолчанию Jest тесты завершаются, как только они достигают конца их исполнения

// Не делайте так!
// test('данные являются арахисовым маслом', () => {
//   function callback(data) {
//     expect(data).toBe('арахисовое масло');
//   }

//   fetchData(callback);
// });

// Проблема в том, что тест завершится, как только завершится выполнение fetchData, прежде чем будет вызван callback.

// Существует альтернативная форма test, которая исправляет это.
// Вместо того чтобы помещать тест в функцию с пустым аргументом, передавайте в нее аргумент с именем done.
// Перед завершением теста Jest будет ждать вызова done, и только потом тест завершится.

// test('данные являются арахисовым маслом', (done) => {
//   function callback(data) {
//     try {
//       expect(data).tobe('арахисовое масло');
//       done();
//     } catch (error) {
//       done(error);
//     }
//   }

//   fetchData(callback);
// });
// Если done() никогда не вызовется, тест упадет (по тайм-ауту), а это как раз то, чего мы хотим.
// Если expect завершится неудачно, то он выбросит ошибку и done() не будет вызван.


// ПРОМИСЫ

// Возвращайте промис в своем тесте, и Jest будет ждать resolve — успешного завершения промиса. 
// Если промис будет выполнен, то тест автоматически прервётся.

// Например, представьте что fetchData вместо использования коллбэка возвращает промис, который должен в случае успешного выполнения вернуть строку 'peanut butter'.

// test('the data is peanut butter', () => {
//   return fetchData().then(data => {
//     expect(data).toBe('peanut butter');
//   });
// });
// Обязательно убедитесь, что вы возвращаете промис — если забыть про этот return, то тест завершится еще до того как успешно завершится промис, вернувшийся из fetchData, и у then() появится возможность выполнить обратный вызов.


// Если Вы ожидаете, что промис будет отклонён, используйте метод .catch. 
// Убедитесь, что добавлены expect.assertions, чтобы убедиться, что вызвано определенное количество проверок. В противном случае, завершённый промис не провалит тест.

// test('the fetch fails with an error', () => {
//   expect.assertions(1);
//   return fetchData().catch(e => expect(e).toMatch('error'));
// });